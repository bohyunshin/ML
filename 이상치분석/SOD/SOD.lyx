#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
% LaTeX에서 한글사용을 위해 사용해야하는 패키지
\usepackage[hangul]{kotex}
\setmainhangulfont{함초롬바탕} % 메인 한글폰트를 지정해줌


% 페이지 스타일 'fancy'를 사용하게 되면, 페이지 윗부분에 줄을 하나 그어줌.
% fancy 스타일을 사용할때 사용할수 있는 옵션은 아래와 같다.
%\lhead{7장 과제} % 줄 왼쪽 부분에 적을 내용
%\chead{Bayes Statistics} % 가운데 부분
%\rhead{김철응 교수님} % 오른쪽 부분
%=====================================%

% \renewcommand\footrulewidth{0.4pt}  % 페이지번호 위에 직선을그어주는 명령어




%=== 문서의 줄간격을 수정해주는 패키지 ===%
\usepackage{setspace} 
\setstretch{1.5} % 간격 임의로 지정 
% \onehalfspacing  한칸반 간격인것 같음
%=====================================%

\usepackage{tikz} % LaTeX으로 Graphical한 작업을 할때 사용하는 패키지



\usepackage{hyperref} % 하이퍼링크 색깔 바꿔주기 위해

% 아래 옵션을 활성화시키면 하이퍼링크걸린 문자들의 색깔이 red로 변함
%\hypersetup{         
%    colorlinks,
%    citecolor=red,
%    filecolor=red,
%    linkcolor=red,
%    urlcolor=red
%}


%\usepackage{multicol} % 표지는 one-column, 본문은 two-column 적용해주기 위해
% 위 명령어를 활성화 시켜준 뒤
% \begin{multicols}{2}    \end{multicols} 사이에 본문을 작성하면
% 그 부분만 column이 나눠짐
\end_preamble
\options most, usenames, dvipsnames
\use_default_options true
\begin_modules
tcolorbox
theorems-ams
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8-plain
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\output_sync_macro "\synctex=1"
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic true
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip bigskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\b}{\beta}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\a}{\alpha}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\ddd}{\cdots}
\end_inset


\begin_inset FormulaMacro
\newcommand{\shat}[1]{\hat{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\lhat}[1]{\widehat{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\inf}{\infty}
\end_inset


\begin_inset FormulaMacro
\newcommand{\lam}{\lambda}
\end_inset


\begin_inset FormulaMacro
\newcommand{\df}[2]{\dfrac{#1}{#2}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\ss}[1]{\left(#1\right)}
\end_inset


\begin_inset FormulaMacro
\newcommand{\mm}[1]{\left\{  #1\right\}  }
\end_inset


\begin_inset FormulaMacro
\newcommand{\ll}[1]{\left[#1\right]}
\end_inset


\begin_inset FormulaMacro
\newcommand{\si}{\sigma}
\end_inset


\begin_inset FormulaMacro
\newcommand{\rr}[1]{\sqrt{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\d}{\cdot}
\end_inset


\begin_inset FormulaMacro
\newcommand{\ones}{\,}
\end_inset


\begin_inset FormulaMacro
\newcommand{\twos}{\:}
\end_inset


\begin_inset FormulaMacro
\newcommand{\threes}{\;}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\d}{\delta}
\end_inset


\begin_inset FormulaMacro
\newcommand{\app}{\thickapprox}
\end_inset


\begin_inset FormulaMacro
\newcommand{\ep}{\epsilon}
\end_inset


\begin_inset FormulaMacro
\newcommand{\pro}{\times}
\end_inset


\begin_inset FormulaMacro
\newcommand{\ovv}[1]{\overline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\right}{\longrightarrow}
\end_inset


\end_layout

\begin_layout Title

\shape smallcaps
\size normal
Yonsei University, Department of Applied Statistics
\begin_inset VSpace 0.1cm
\end_inset


\shape default
\size default
 
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.5pt"

\end_inset


\begin_inset VSpace 0.4cm
\end_inset


\series bold
\size giant
Subspace Outlier Detection
\series default
\size default

\begin_inset VSpace 0.5cm
\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "2pt"

\end_inset


\begin_inset VSpace 4in
\end_inset


\end_layout

\begin_layout Author
12기 신보현
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
0.
 Reference Paper
\begin_inset Newline newline
\end_inset

Outlier Detection in Axis-Parallel Subspaces of High Dimensional Data by
 Hans-Peter Kriegel, Peer Kr¨oger, Erich Schubert, and Arthur Zimek
\begin_inset Newline newline
\end_inset

pdf 
\begin_inset Formula $ $$ $

\end_inset

http://www.dbs.ifi.lmu.de/Publikationen/Papers/pakdd09_SOD.pdf
\end_layout

\begin_layout Standard
1.
 Intuition
\end_layout

\begin_layout Standard
ABOD에 이어서 고차원 데이터에서 이상치를 찾는 기법을 소개한다.
 ABOD는 고차원 데이터에서 데이터들 간의 거리가 가지는 의미가 없어짐에 따라, 거리와 추가적으로 각도의 개념을 혼합하여 이상치를
 분서하는 기법이었다.
 하지만 이 때, 모든 feature을 사용하였다.
 다시 말해, 고차원 데이터는 많은 feature들이 있을 것이고, 그 중 반응변수와 관련이 없는, noise한 feature들이
 있을텐데, ABOD는 우선 이러한 feature들을 모두 사용한다.
 SOD는 이러한 방법에 의문을 던진다.
 반응변수와 관련성이 떨어지는 feature을 포함하여 이상치를 탐지하려고 한다면 왜곡된 결과가 나올 수 있음을 먼저 지적한다.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename 그림/1.png
	scale 70

\end_inset


\begin_inset Newline newline
\end_inset

Figure 1
\end_layout

\begin_layout Standard
Figure 1의 (a)을 보자.
 full dimension으로 축 
\begin_inset Formula $A_{1},A_{2}$
\end_inset

를 모두 고려해보자.
 2차원 평면에서 o라고 표시된 점은 x로 표시된 다른 점들과 크게 달라 보이지 않는다.
 거리상으로, 밀도상으로 '이상치'라고 탐지할만큼의 특이한 메커니즘은 눈으로 봤을 때도 나타나지 않는 듯 하다.
 바로 이러한 상황이 고차원 데이터에서 모든 차원을 고려하여 이상치를 탐지하려고 할 때 나타나는 문제점이다.
\begin_inset Newline newline
\end_inset

이제 축 
\begin_inset Formula $A_{1}$
\end_inset

만 고려해보자.
 축 
\begin_inset Formula $A_{1}$
\end_inset

만을 기준으로 생각 한다면 x로 표시된 점들은 꽤 가까이 있고 o로 표시된 점은 이 점들과는 다소 멀리 떨어져 있음을 알 수 있다.
\begin_inset Newline newline
\end_inset

다음으로 축 
\begin_inset Formula $A_{2}$
\end_inset

만 고려해보자.
 축 
\begin_inset Formula $A_{2}$
\end_inset

만을 기준으로 생각한다면 x로 표시된 점들이나 o로 표시된 점이나 다소 큰 차이가 없어 보인다.
 즉 모든 점들이 uniform하게 퍼져있음을 알 수 있다.
\begin_inset Newline newline
\end_inset

축 
\begin_inset Formula $A_{1}$
\end_inset

과 축 
\begin_inset Formula $A_{2}$
\end_inset

는 어떤 차이점을 가질까? 축 
\begin_inset Formula $A_{1}$
\end_inset

만 고려를 하면 앞서 살펴보았듯이, 데이터들의 경향성을 파악할 수 있었다.
 즉, 이 축은 반응변수와 연관되어 있는 변수라고 볼 수 있다.
 그러나 축 
\begin_inset Formula $A_{2}$
\end_inset

만 고려를 하면 축 
\begin_inset Formula $A_{1}$
\end_inset

만 봤을 때 어떤 군집을 이루던 데이터들이 uniform하게 퍼져있게 보여, 마치 데이터들이 아무 상관이 없는 것처럼 보인다.
 다시 말하면, 축 
\begin_inset Formula $A_{2}$
\end_inset

는 noise한 변수라고 볼 수 있다.
\begin_inset Newline newline
\end_inset

위의 논의를 종합해보자.
 Figure 1의 (a)의 간단한 예시에서, 데이터들의 메커니즘과 관련되어 있는 변수(축)을 기준으로 데이터를 살펴 보았을 때,
 데이터들의 경향성을 파악하고 이상치를 탐지하기도 쉬웠다.
 SOD는 이러한 직관에서 출발한다.
\end_layout

\begin_layout Standard
2.
 Algorithm
\end_layout

\begin_layout Standard
SOD의 기본 아이디어는 각 점이 reference points에 의해 생성(span)된 부분 공간(subspace)에 얼마나 잘
 맞는지를 분석하는 것이다.
 어떤 점이 이상치인지 판별하기 위해 reference points을 정하고 그 reference points가 만드는(span)
 부분공간은 noise 축에 평행한 초평면이다(axis-parallel hyperplane) 이렇게 설정된 초평면에 해당 데이터가
 유의미하게 떨어져있으면 해당 데이터는 바로 그 초평면에 수직(perpendicular)인 부분공간에 대해서 이상치로 고려된다.
\begin_inset Newline newline
\end_inset

좀 더 자세하게 살펴보자.
 우선 notation부터 정리를 한다.
 이제부터 여러 notation이 정의될테니, 하나하나 꼼꼼하게 짚고 넘어가자.
 그래야 이후 나올 개념들이 헷갈리지 않는다.
\begin_inset Formula 
\[
suppose\ones\mathcal{D}\subseteq\mathbb{R}^{d}\ones is\ones a\ones database\ones of\ones n\ones points\ones in\ones a\ones d-dimensional\ones feature\ones space
\]

\end_inset


\begin_inset Formula 
\[
and\ones dist\ones is\ones a\ones metric\ones distance\ones function\ones on\ones the\ones points\ones in\ones\mathcal{D}
\]

\end_inset


\begin_inset Formula 
\[
\mathcal{S}\ones is\ones the\ones reference\ones set
\]

\end_inset


\begin_inset Formula 
\[
For\ones any\ones point\ones p\in\mathbb{R}^{d},\ones we\ones denote\ones the\ones projection\ones of\ones p\ones onto\ones attribute\ones i\ones by\ones p_{i}
\]

\end_inset

위에서 잠깐 언급했지만, reference set인 
\begin_inset Formula $\mathcal{S}$
\end_inset

가 만드는(span하는) 부분공간을 noise 축에 평행하게 설정 한다(axis-parallel hyperplane) 이해를 위해
 Figure 1의 (b)을 보자.
 이후에 설명을 하겠지만, 여기서 
\begin_inset Formula $\mathcal{S}$
\end_inset

가 만드는 부분공간은 빨강색 굵은 선이다.
 자세히 보면 이것이 noise한 
\begin_inset Formula $A_{2}$
\end_inset

축과 평행함을 확인할 수 있다.
 즉, 다른 축과 달리 
\begin_inset Formula $A_{2}$
\end_inset

축 기준으로 보면, 데이터들의 분산이 크다.
 다시 말하면, 균등하게 퍼져있다.
 따라서 
\begin_inset Formula $A_{2}$
\end_inset

축이 noise하다고 판단하고 이에 평행하게(parallel) 부분공간을 설정한 것이다.이 논문의 제목 중 일부인 Axis-Parallel
 이라는 말도 여기서 비롯된 것으로 보인다.이렇게 noise 축에 대해서 평행하게 부분공간을 설정하면 다른 축(
\begin_inset Formula $A_{1},A_{3})$
\end_inset

과는 수직(perpendicular)인 것을 확인할 수 있다.
 Figure 1의 (b)에서 
\begin_inset Formula $A_{1},A_{3}$
\end_inset

 축은 의미가 있는 축이다.
 다시 말해, 이 축에 대해서 데이터들의 분산은 작고 
\begin_inset Formula $o$
\end_inset

라고 표시된 점만 동떨어져 있음을 확인할 수 있다.
 여태까지의 논의를 정리하면, reference set인 
\begin_inset Formula $\mathcal{S}$
\end_inset

가 만드는 부분공간은 어떻게든 설정할 수 있다.
 
\begin_inset Formula $A_{1},A_{2},A_{3}$
\end_inset

 축 중 어느 것과 평행하게, 수직하도록, 또른 특정한 각도를 이루도록 설정할 수 있는데, 이 논문에서는 특정하게 noise한 축과
 평행한 부분공간을 생각한다.
 그렇게 설정하면 자연스럽게 noise한 축과 수직인 축은 유의미한 축이 되기 때문이다.
\begin_inset Newline newline
\end_inset

따라서 
\begin_inset Formula $\mathcal{S}$
\end_inset

의 부분공간인 초평면은 해당 초평면에 대해서 
\begin_inset Formula $\mathcal{S}$
\end_inset

안에 있는 점들의 분산이 높고 그 초평면과 수직인 부분공간에 대해서는 
\begin_inset Formula $\mathcal{S}$
\end_inset

안에 있는 점들의 분산이 낮은 특징을 가진다.
 
\begin_inset Formula $\mathcal{S}$
\end_inset

의 분산인 
\begin_inset Formula $VAR^{\mathcal{S}}$
\end_inset

은 평균인 
\begin_inset Formula $\mu^{\mathcal{S}}$
\end_inset

(논문에서는 mean value라나와고 있었음)에 대한 
\begin_inset Formula $\mathcal{S}$
\end_inset

 점들의 평균 제곱(average squared)거리이다, ie., 
\begin_inset Formula $VAR^{\mathcal{S}}=\df{\sum_{p\in\mathcal{S}}dist(p,\mu^{\mathcal{S}})^{2}}{Card(\mathcal{S})}$
\end_inset

, 여기서 
\begin_inset Formula $Card(\mathcal{S})$
\end_inset

은 
\begin_inset Formula $\mathcal{S}$
\end_inset

의 점의 갯수를 의미한다.
 유사하게, 어떤 attribute(feature, predictor, 변수라고 해석하면 됨)에 대한 분산은 
\begin_inset Formula $var_{i}^{\mathcal{S}}=\df{\sum_{p\in\mathcal{S}}dist(p_{i},\mu_{i}^{\mathcal{S}})^{2}}{Card(\mathcal{S})}$
\end_inset

로 정의된다.
 여기서, 
\begin_inset Formula $p_{i}$
\end_inset

의 정의는 점 
\begin_inset Formula $p$
\end_inset

를 attribute i에 projection시킨 점임을 다시 한번 상기하자.
 다시 말하면, 어떤 attribute에 대한 분산은 데이터를 그 attribute(=축)으로 projection한 점들의 분산을
 구한 것이다.
\begin_inset Newline newline
\end_inset

이제 점 p에 대한 reference points를 
\begin_inset Formula $R(p)\subseteq\mathcal{D}$
\end_inset

로 정의하고 이를 reference set이라하자(여태까지 계속 언급한 
\begin_inset Formula $\mathcal{S}$
\end_inset

을 '점 
\begin_inset Formula $p$
\end_inset

'에 대한 reference set으로 다시 정의한 것일 뿐이다) 방금 정의한 reference set을 통해서 p의 outlierness가
 평가될 것이다.
\begin_inset Newline newline
\end_inset

또 다른 notation을 정의한다.
 
\begin_inset Formula $v^{R(p)}\in\mathbb{R}^{d}$
\end_inset

을 subspace defining vector라고 정의하고 이는 
\begin_inset Formula $R(p)$
\end_inset

에 의해 정의된 부분공간의 relevant attributes을 보여준다.
 즉, subspace defining vector인 
\begin_inset Formula $v^{R(p)}$
\end_inset

은 어떤 축이 noise한 축이고 어떤 축이 유의미한 축인지 알려주는 벡터라고 생각하면 편하다.
 여기서 의미있는 축, 즉 의미있는 attribute은 앞서 많이 언급했듯이, 그 축에대한 분산의 높고 낮음으로 판단한다.
 그에 따라서 높은 분산과 낮은 분산의 기준이 필요할텐데, 이를 아래와 같이 정의한다.
\begin_inset Newline newline
\end_inset

모든 d개의 attributes(위에서 살펴보았듯이 feature라고 생각하면 편함)들 중에서 점들은 total variance인
 
\begin_inset Formula $VAR^{R(p)}$
\end_inset

을 가진다.
 따라서 i번째 attribute가 가질 것으로 기대되는 분산은 
\begin_inset Formula $VAR^{R(p)}/d$
\end_inset

이다.(어째서 갑자기 그 갯수만큼 나누는지 정확히 이해가 가지 않는 부분이다.
 논문의 내용을 우선 그대로 옮겼다.) 만약 
\begin_inset Formula $var_{i}^{R(p)}$
\end_inset

가 기대되는 분산(
\begin_inset Formula $VAR^{R(p)}/d$
\end_inset

)에 
\begin_inset Formula $\alpha$
\end_inset

(미리 정해진 계수)배를 한 것보다 작으면 i번째 attribute에 대한 점들의 분산이 낮다고 판단을 한다.
 
\begin_inset Formula $R(p)$
\end_inset

가 낮은 분산을 가지는(방금 전 문장의 조건이 충족될 때) attribute에 대해서 해당 subspace defining vector인
 
\begin_inset Formula $v_{i}^{R(p)}$
\end_inset

를 1이라고 설정하고 나머지는 0이라고 설정한다.
 이를 다시 표현하면 아래와 같다.
\begin_inset Formula 
\[
v_{i}^{R(p)}=\begin{cases}
1 & if\ones var_{i}^{R(p)}<\alpha\df{VAR^{R(p)}}d\\
0 & o.w
\end{cases}
\]

\end_inset

쉽게 말하면 subspace defining vector은 요소 값으로 유의미한 축에 대해서는 1, 무의미한 축에 대해서는 0의
 값을 가진다.
\begin_inset Newline newline
\end_inset

reference points인 
\begin_inset Formula $R(p)$
\end_inset

의 부분공간 초평면(subspace hyperplane, 위에서 언급한 Axis-Parallel Subspace)인 
\begin_inset Formula $\mathcal{H}(R(p))$
\end_inset

는 
\begin_inset Formula $R(p)$
\end_inset

의 평균인 
\begin_inset Formula $\mu^{R(p)}$
\end_inset

와 subspace defining vector인 
\begin_inset Formula $v^{R(p)}$
\end_inset

로 정의된다, ie.
 
\begin_inset Formula $\mathcal{H}(R(p))=(\mu^{R(p)},v^{R(p)})$
\end_inset

 
\begin_inset Formula $\mu^{R(p)},v^{R(p)}$
\end_inset

로 정의된다는 말은 마치 정규분포를 평균과 분산으로 정의한다는 느낌으로 받아들이자.
\begin_inset Newline newline
\end_inset

여태까지 여러 개념을 정의했는데, Figure1의 (b)을 보며 정의한 개념을 정리해보자.
 
\begin_inset Formula $R(o)$
\end_inset

는 점 
\begin_inset Formula $o$
\end_inset

에 대한 reference points이다.
 또한 
\begin_inset Formula $\mathcal{H}(R(o))$
\end_inset

은 
\begin_inset Formula $R(o)$
\end_inset

의 subspace hyperplane이고 축 
\begin_inset Formula $A_{2}$
\end_inset

에 대해서는 큰 분산을 가지지만 축 
\begin_inset Formula $A_{1},A_{3}$
\end_inset

에 대해서는 작은 분산을 가짐을 확인할 수 있다.
 즉, 이를 통해 축 
\begin_inset Formula $A_{2}$
\end_inset

는 irrelevant attribute이고 축 
\begin_inset Formula $A_{1},A_{3}$
\end_inset

은 relevant attribute임을 알 수 있다.
 
\begin_inset Formula $R(o)$
\end_inset

에 대한 subspace defining vector인 
\begin_inset Formula $v^{R(o)}$
\end_inset

을 살펴보자.
 방금 말했듯이, 축 
\begin_inset Formula $A_{1},A_{3}$
\end_inset

이 relevant하고 축 
\begin_inset Formula $A_{2}$
\end_inset

는 그렇지 않으므로 
\begin_inset Formula $v^{R(o)}=(1,0,1)^{T}$
\end_inset

임을 확인할 수 있다.
 또한 정의에 의해 
\begin_inset Formula $\mathcal{H}(R(o))=(\mu^{R(o)},v^{R(o)})$
\end_inset

이고 축 
\begin_inset Formula $A_{1},A_{3}$
\end_inset

와 수직인 빨강색 굵은 선으로 표시가 되어 있다.
\begin_inset Newline newline
\end_inset

이제 점 
\begin_inset Formula $o$
\end_inset

가 subspace hyperplane인 
\begin_inset Formula $\mathcal{H}(R(o))$
\end_inset

와 얼마나 떨어져있는지 측정할 수 있다.
 떨어진 정도는 
\begin_inset Formula $o$
\end_inset

과 
\begin_inset Formula $\mu^{R(o)}$
\end_inset

의 거리를 subapce defining vector인 
\begin_inset Formula $v^{R(o)}$
\end_inset

로 가중치를 한 weighted Euclidean distance으로 측정을 한다.
\begin_inset Formula 
\[
dist(o,\mathcal{H}(R(o)))=\rr{\sum_{i=1}^{d}v_{i}^{R(o)}\cdot(o_{i},\mu_{i}^{R(o)})^{2}}
\]

\end_inset

수식으로만 보면 피부로 와닿지 않을 것이다.
 Figure 1의 (c)에 있는 예시를 보자.
 점 
\begin_inset Formula $o$
\end_inset

와 
\begin_inset Formula $\mathcal{H}(R(o))$
\end_inset

와의 거리가 초록색으로 
\begin_inset Formula $dist(\mathcal{H}(R(o)),p)$
\end_inset

라고 표시되어 있다(여기서 
\begin_inset Formula $p$
\end_inset

는 
\begin_inset Formula $o$
\end_inset

와 동일하다)
\begin_inset Newline newline
\end_inset

축 
\begin_inset Formula $A_{1}$
\end_inset

에 있는 
\begin_inset Formula $o_{1}$
\end_inset

을 보자.
 앞서 정의했듯이, 
\begin_inset Formula $p_{i}$
\end_inset

는 점 
\begin_inset Formula $p$
\end_inset

를 i번째 attribute에 projection한 점이다.
 따라서 
\begin_inset Formula $o_{1}$
\end_inset

은 점 
\begin_inset Formula $o$
\end_inset

를 첫 번째 attribute, 여기서는 
\begin_inset Formula $A_{1}$
\end_inset

로 projection한 점이다.
 
\begin_inset Formula $o_{3}$
\end_inset

도 마찬가지이다.
 
\begin_inset Formula $\mu_{1}^{R(o)},\mu_{3}^{R(o)}$
\end_inset

도 동일하게 이해하자.
 이제 
\begin_inset Formula $dist(\mathcal{H}(R(o)),p)$
\end_inset

을 빗변으로 직각 삼각형에 주목 하자.
 피타고라스 정리에 의해서 
\begin_inset Formula $dist(\mathcal{H}(R(o)),p)$
\end_inset

의 제곱은 나머지 두 변의 제곱의 합이다.
 방금 살펴본 
\begin_inset Formula $dist(\mathcal{H}(R(o)),p)$
\end_inset

값을 구하는 과정은 위의 
\begin_inset Formula $dist(\mathcal{H}(R(o)),p)$
\end_inset

 정의와 동일하다.
 weight vector인 
\begin_inset Formula $v_{i}^{R(o)}$
\end_inset

은 그 성분은 1 또는 0이고 이는 indicator value에 불과하다.
 즉, irrelevant하다고 생각되는 attribute을 제외한 유의미한 attribute에 대해서 거리를 계산하라는 뜻으로,
 Figure 1의 (c)와 동일한 맥락이다.
\begin_inset Newline newline
\end_inset

여기서는 
\begin_inset Formula $dist(o,\mathcal{H}(R(o)))$
\end_inset

을 이해하기 위해서 피타고라스 개념을 이용했다.
 하지만 필자의 생각으로, 이는 Figure 1의 (c)의 저차원에서나 적용할 수 있을듯하다.
 우선 
\begin_inset Formula $dist(o,\mathcal{H}(R(o)))$
\end_inset

 공식을 저차원에서 이해했으니 고차원에서도 이와 비슷하게 작동할 것이라고 생각하자.
\begin_inset Newline newline
\end_inset

만약 
\begin_inset Formula $dist(\mathcal{H}(R(o)),p)$
\end_inset

이 0에 가깝다면 어떠한 점 
\begin_inset Formula $o$
\end_inset

가 
\begin_inset Formula $\mathcal{H}(R(o))$
\end_inset

에 잘 맞는(원문에는 fits라는 표현)다는 의미이고 이는 곧 이상치가 아니라는 뜻이다.
 반면에 높은 
\begin_inset Formula $dist(\mathcal{H}(R(o)),p)$
\end_inset

은 이상치일 가능성이 높다는 뜻이다.
 마지막으로 Subspace Outlier Degree(SOD)는 아래와 같이 정의된다.
\begin_inset Formula 
\[
SOD_{R(p)}(p):=\df{dist(p,\mathcal{H}(R(o)))}{||v^{R(p)}||}
\]

\end_inset

기존의 모델들과는 달리 SOD는 왜 점 
\begin_inset Formula $p$
\end_inset

가 이상치인지를 알려준다.
 점 
\begin_inset Formula $p$
\end_inset

가 이상치라고 판단이 되면, 어떤 부분공간에서 점 
\begin_inset Formula $p$
\end_inset

가 이상치인지를 알아낼 수 있다.
 앞서 정의된 subspace defining vector인 
\begin_inset Formula $v^{R(p)}$
\end_inset

는 reference points가 만들어낸 subspace hyperplane에 수직인 부분공간에 대한 정보를 담고 있다.
 따라서 
\begin_inset Formula $v^{R(p)}$
\end_inset

을 통해 이를 살펴봄으로써 점 
\begin_inset Formula $p$
\end_inset

가 이상치라고 판명이 되는 부분공간을 살펴볼 수 있다.
 
\end_layout

\begin_layout Standard
이제 의미있는 reference set을 선택하는 과정에 대해서 살펴보자.
 현재 존재하는 local (full dimensional) outlier detection 모델은 점 
\begin_inset Formula $p$
\end_inset

의 local neighborhood을 살펴본다.
 즉, 다시 말해 Euclidean distance를 기반으로 해서 가장 가까운 k개의 점들을 살펴본다.
 하지만 서두에서 말했듯이, 고차원 데이터일 수록 차원의 저주로 인해서 점들 간의 거리가 가지는 의미가 없어진다.
\begin_inset Newline newline
\end_inset

SNN 접근법은 공통으로 가장 가까운 이웃의 갯수에 기반하여 점들의 유사도를 측정한다.
 SNN 접근법은 어떠한 점 
\begin_inset Formula $p$
\end_inset

에 대해서 모든 점들이 거의 같은 거리에 있을지라도, 가장 가까운 이웃의 'Ranking'은 여전히 의미가 있다는 생각에서 출발한다.
\begin_inset Newline newline
\end_inset

동일한 메커니즘에 의해서 생성된 두 점, p와 q를 생각해보자.
 이 두점은 동일한 메커니즘에 의해서 생성되었기 때문에, 이들은 이웃이거나 동일한 메커니즘과 관련된 부분공간에서의 유사한 이웃을
 가질 것이다.
 여기에 불필요한 attributes을 추가하는 것은 절대적인 거리로 측정한 이웃 관계를 흐리게 할 것이다.
 그럼에도, 가장 가까운 데이터는 크게 변하지 않을 것이다.
 따라서 이들이 같은 메커니즘에 의해서 생성되었다면 점 p와 q는 공유하는 이웃들이 많을 것이다.
 
\begin_inset Newline newline
\end_inset

위의 아이디어를 정리해보자.
\begin_inset Formula 
\[
Let\ones N_{k}(p)\in\mathcal{D}\ones be\ones the\ones k-nearest\ones neighbors\ones p\in\mathcal{D}\ones w.r.t\ones the\ones distance\ones function\ones dist
\]

\end_inset


\begin_inset Formula 
\[
The\ones shared\ones nearest\ones neighbor\ones similarity\ones beyween\ones two\ones points\ones p,q\in\mathcal{D}\ones is\ones defined\ones as
\]

\end_inset


\begin_inset Formula 
\[
sim_{SNN}(p,q)=Card(N_{k}(p)\cap N_{k}(q))
\]

\end_inset

이제 reference set인 
\begin_inset Formula $R(p)$
\end_inset

을 
\begin_inset Formula $sim_{SNN}$
\end_inset

을 사용하여 
\begin_inset Formula $p$
\end_inset

와 가장 가까운 
\begin_inset Formula $l$
\end_inset

개의 점이라고 정의한다.
 즉,
\begin_inset Formula 
\[
the\ones reference\ones set\ones R(p)\ones of\ones p\ones is\ones the\ones set\ones of\ones l-nearest\ones neighbors\ones of\ones p\ones using\ones sim_{SNN}
\]

\end_inset


\begin_inset Formula 
\[
in\ones other\ones words,\ones a\ones subset\ones of\ones\mathcal{D}\ones that\ones contains\ones l\ones points\ones according\ones to\ones the\ones following\ones condition:
\]

\end_inset


\begin_inset Formula 
\[
\forall o\ones\in R(p),\ones\forall\shat o\in\mathcal{D}\smallsetminus R(p):\ones sim_{SNN}(\shat o,p)\leq sim_{SNN}(o,p)
\]

\end_inset

마지막 줄의 condition을 살펴보자.
 이를 다시 말로 풀어보면 다음과 같다.
\begin_inset Newline newline
\end_inset

reference set에 있는 모든 점 
\begin_inset Formula $o$
\end_inset

과 
\begin_inset Formula $\mathcal{D}$
\end_inset

에서 reference set을 제외한 모든 점 
\begin_inset Formula $\shat o$
\end_inset

에 대해서 점 
\begin_inset Formula $o$
\end_inset

와 점 
\begin_inset Formula $p$
\end_inset

의 SNN 값이 점 
\begin_inset Formula $\shat o$
\end_inset

와 점 
\begin_inset Formula $p$
\end_inset

의 SNN 값보다 크다는 뜻이다.
 위에서 살펴보았듯이, 어떤 두점의 SNN 값이 크다는 것은, 각 점에서 가장 가까운 k개의 이웃을 뽑았을 때, 공통으로 있는 이웃의
 수가 크다는 것이고, 이는 즉 동일한 메커니즘에서 나왔을 가능성이 큼을 의미한다.
 여기서 주목해야할 점은, 점 
\begin_inset Formula $p$
\end_inset

는 우리가 이상치인지 확인하고자 하는 점이라는 것이다.
 즉 점 
\begin_inset Formula $o,p$
\end_inset

의 SNN 값을 구한다는 것은, 이상치인지 확인하고자 하는 점과 이를 확인하기 위한 reference set의 점들간의 SNN를
 구한다는 것이다.
 위의 조건을 살펴보면 이상치인지 확인하고자 하는 점인 
\begin_inset Formula $p$
\end_inset

와 그에 대한 reference set의 점 간의 SNN 값이 크다는 조건이고 이는 곧, SNN 정의에 따르면 
\begin_inset Formula $p$
\end_inset

와 reference set의 점들이 동일한 메커니즘에서 나왔을 가능성이 크다는 뜻이다.
 
\begin_inset Newline newline
\end_inset

이상치를 판별하기 위해 그와 동일한 메커니즘에서 나올법한 점들을 뽑는다는 것이 얼핏 보면 이해가 가질 않는다(SNN 값이 크다는
 것은 두 점이 동일한 메커니즘에서 나왔다는 가능성이 크다는 말은 논문에서 직접적으로 언급되었다) 동일한 메커니즘에서 나왔올 법하다는
 말을 두 점간의 '거리'가 가깝다는 뜻으로 받아들이면 조금은 쉽게 이해할 수 있다.
 물론 SNN은 두 점간의 '거리'를 고차원 데이터에서 차원의 저주로 인해서 Euclidean distance로 구하지는 않고 SNN
 값을 통해 '우회적'으로 구현한 것이다.
 따라서 SNN 값이 크다는 것은 두 점이 동일한 메커니즘에서 나왔다, 즉 두점 간의 '거리'가 가까운 것이라고 할 수 있다.
 이러한 생각을 가지면, 
\begin_inset Formula $sim_{SNN}(\shat o,p)\leq sim_{SNN}(o,p)$
\end_inset

을 쉽게 이해할 수 있다.
 reference set의 점인 
\begin_inset Formula $o$
\end_inset

와 
\begin_inset Formula $p$
\end_inset

와의 SNN 값이 reference set이 아닌 점인 
\begin_inset Formula $\shat o$
\end_inset

와 
\begin_inset Formula $p$
\end_inset

와의 SNN 값보다 크다는 뜻이다.
 즉, reference set의 점들을 SNN 값이 큰 점들로, 다시 말하면 점 
\begin_inset Formula $p$
\end_inset

와의 '거리'(여기서는 SNN을 통한 우회적인 거리)가 가까운 점들로 설정한다는 뜻이다.
 이를 다시 생각해보자.
\begin_inset Newline newline
\end_inset

어떤 점 
\begin_inset Formula $p$
\end_inset

의 이상치 정도를 확인하고자 할 때, 우선 가장 가까운 점들과의 거리를 보는 것은 나름 합당한 판단 기준으로 보인다.
 왜냐하면 점 
\begin_inset Formula $p$
\end_inset

의 멀리 있는 점을 본다면, 실제로는 멀리 있는 것이 맞지만, 알고보니 그 중간에 많은 점들이 있을 수 있기 때문이다.
 하지만 가장 가까운 거리점들을 본다면, 가장 가까운 점이 실제로는 멀리 있을 수도, 가까울 수도 있는데 가장 가깝다는 말로 인해서
 그 중간에 다른 점들이 없다.
 이러한 이유로 인해서 reference set을 정할 때, 가장 가까운 거리에 있는 점들을 설정하고, 이때, 고차원의 저주를 고려하여
 Euclidean Distance으로 거리를 계산하지 않고 SNN을 이용하여 우회적으로 거리의 개념을 표현하는 것이다.
\end_layout

\begin_layout Standard
SOD 모델은 두 parameters에 의존한다.
 먼저 reference set을 결정하는데 사용되는 
\begin_inset Formula $sim_{SNN}$
\end_inset

에서의 k이다.
 이는 그렇게 중요한 모수는 아니며 점들간의 공통의 메카니즘을 알아내기 위해 적당히 크게 설정하면 된다.
\begin_inset Newline newline
\end_inset

둘 째로 reference set의 크기인 
\begin_inset Formula $l$
\end_inset

이다.
 위와 동일한 이유로 너무 작게 설정하지 않으면 된다.
 당연히, 
\begin_inset Formula $l$
\end_inset

은 
\begin_inset Formula $k$
\end_inset

보다 작거나 같게 설정되어야 할 것이다.
\begin_inset Newline newline
\end_inset

셋 째로 subspace defining vector에서 attribute의 중요도에대해서 결정하기 위한 threshold인 
\begin_inset Formula $\alpha$
\end_inset

 또한 정해야 한다.
 이 논문에서는 
\begin_inset Formula $\alpha=0.8$
\end_inset

로 설정했으니 이와 같이 설정하라고 하고 구현된 R 코드에서도 0.8이 기본값이기도 하다.
\end_layout

\begin_layout Standard
3.
 Codes in python and R
\end_layout

\begin_layout Standard
python 
\begin_inset Formula $\longrightarrow$
\end_inset

 찾지 못했음.
\end_layout

\begin_layout Standard
R 
\begin_inset Formula $\longrightarrow$
\end_inset

https://cran.r-project.org/web/packages/HighDimOut/HighDimOut.pdf
\begin_inset Newline newline
\end_inset

여기에는 저번에 발제한 ABOD 기법도 있다.
 고차원 데이터에서 이상치 발굴하기에 특화된 패키지!!!
\end_layout

\begin_layout Standard
4.
 Kaggle data
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename C:/Users/sbh0613/Desktop/와이빅타/이상치분석/1주차 그림/4.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<message=FALSE>>=
\end_layout

\begin_layout Plain Layout

data = read.csv("C:/Users/sbh0613/Desktop/와이빅타/이상치분석/creditcardfraud/creditcard.cs
v",header=T)
\end_layout

\begin_layout Plain Layout

library(HighDimOut)
\end_layout

\begin_layout Plain Layout

table(data$Class)
\end_layout

\begin_layout Plain Layout

which(data$Class == 1)[1:10]
\end_layout

\begin_layout Plain Layout

which(names(data) == 'Class')
\end_layout

\begin_layout Plain Layout

start_time = Sys.time()
\end_layout

\begin_layout Plain Layout

sod.result = Func.SOD(data[500:550,-31],k.nn=5,k.sel=5,alpha=0.8)
\end_layout

\begin_layout Plain Layout

end_time = Sys.time()
\end_layout

\begin_layout Plain Layout

#running time
\end_layout

\begin_layout Plain Layout

end_time - start_time
\end_layout

\begin_layout Plain Layout

sod.result.mat = cbind(sod.result,500:550)
\end_layout

\begin_layout Plain Layout

sod.result.mat = sod.result.mat[order(sod.result,decreasing=TRUE),]
\end_layout

\begin_layout Plain Layout

sod.result.mat[1:10,]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
꽤나 높은 등수!! parameter을 바꿔보자.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

sod.result = Func.SOD(data[500:550,-31],k.nn=3,k.sel=5,alpha=0.8)
\end_layout

\begin_layout Plain Layout

sod.result.mat = cbind(sod.result,500:550)
\end_layout

\begin_layout Plain Layout

sod.result.mat = sod.result.mat[order(sod.result,decreasing=TRUE),]
\end_layout

\begin_layout Plain Layout

sod.result.mat[1:10,]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
이제 모든 행에 해보자.
 하지만 에러..
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename 그림/2.png

\end_inset


\end_layout

\begin_layout Standard
구글링 
\begin_inset Formula $\longrightarrow$
\end_inset

https://stackoverflow.com/questions/42479854/merge-error-negative-length-vectors-
are-not-allowed
\begin_inset Newline newline
\end_inset

요약: 계산이 너무 많아서 R이 감당하기 힘듦.
\end_layout

\begin_layout Standard
총 28000개정도의 행이 있는데 이 중 만개의 행을 해보자.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

sod.result.mat = cbind(sod.result,1:10000)
\end_layout

\begin_layout Plain Layout

sod.result.mat = sod.result.mat[order(sod.result,decreasing=TRUE),]
\end_layout

\begin_layout Plain Layout

colnames(sod.result.mat) = c("value","index")
\end_layout

\begin_layout Plain Layout

head(sod.result.mat)
\end_layout

\begin_layout Plain Layout

fraud.index = which(data$Class == 1)[ which(data$Class == 1) <= 10000 ]
\end_layout

\begin_layout Plain Layout

rank.vec = c()
\end_layout

\begin_layout Plain Layout

for (i in 1:length(fraud.index)){ 
\end_layout

\begin_layout Plain Layout

for (j in 1:length(sod.result.mat[,"index"]) ){ 
\end_layout

\begin_layout Plain Layout

if (fraud.index[i] == sod.result.mat[,"index"][j]) rank.vec[i] = j 
\end_layout

\begin_layout Plain Layout

}    
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

cbind(fraud.index,rank.vec)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename 그림/3.png

\end_inset


\end_layout

\begin_layout Standard
24분이 걸렸다! ABOD는 몇 시간을 둬도 결과가 안 나왔는데, SOD가 계산량이 적음을 알 수 있었다.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename 그림/5.png

\end_inset


\begin_inset Newline newline
\end_inset

Result 1
\end_layout

\begin_layout Standard
위의 결과는 1~10000번째까지 행을 뽑아서 SOD를 연산한 뒤에, SOD 값이 큰 순서부터(이상치일 가능성이 가장 큰 순서부터)
 나열한 결과다(상위 10개의 행) value는 SOD 값이고 index는 data에서의 행 index이다.
\begin_inset Newline newline
\end_inset

이제 실제로 신용카드 사기를 친 행이 결과 1에서 몇 번째 행에 있었는지, 즉 이상치 순위에서 몇 등을 했는지 알아보자.
 아래는 그 결과다.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename 그림/4.png
	scale 70

\end_inset


\begin_inset Newline newline
\end_inset

Result 2
\end_layout

\begin_layout Standard
결과 2에서 fraud.index는 데이터에서 실제로 신용카드사기를 한 행의 index이고 rank.vec은 결과 1로부터 도출한 이상치
 순위이다.
 즉, 결과 2에서 542번째 신용카드사기 행은 만 개의 데이터에서 SOD를 돌리고 내림차순으로 정렬한 결과 그 값이 1298번째로
 컸다는 의미이다.
 데이터가 총 10000개가 있으며 1등부터 10000등까지 있다고 생각할 때, 위의 결과 2는 나름 결과가 잘 나온듯 하다.
 몇몇 네 자리수를 제외하면 대부분 세 자리수이며 500등 이내에 진입한 행도 많이 보인다.
\end_layout

\begin_layout Standard
Func.SNN은 input으로 Func.SOD와 동일하게 k.nn, k.sel이 필요하다.
 k.nn은 shared nearest neighbors을 계산하기 위해 필요한 값이고 k.sel은 shared nearest neighbors의
 수이다.
 즉, SOD에서의 reference set의 수라고 보면 된다.
 이 함수를 실행하면 각 관측치에 대해서 상위 k개의 shared nearest neighbors을 알려준다.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

#SNN
\end_layout

\begin_layout Plain Layout

start_time = Sys.time()
\end_layout

\begin_layout Plain Layout

snn.result = Func.SNN(data[1:10000,-31],k.nn=3,k.sel=10)
\end_layout

\begin_layout Plain Layout

end_time = Sys.time()
\end_layout

\begin_layout Plain Layout

snn.result
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename 그림/6.png

\end_inset


\end_layout

\begin_layout Standard
정리해보면 Func.SOD 함수 안에 이미 Func.SNN 함수를 통해 SNN 값을 계산 한 후에 마지막으로 SOD까지 나오는 것이다.
 그렇다면 왜 따로 Func.SNN이 있을까? 이상치 정도가 높은 관측치에 대한 reference set을 살펴봄으로써, 이 부분공간에
 대해서 이상치로 판별되었다고 알 수 있기 때문인듯 하다.
\end_layout

\end_body
\end_document
